using System;
using System.Globalization;
using System.IO;
using System.Numerics;
using CUE4Parse.UE4.Objects.Core.Math;
using CUE4Parse_Conversion.Animations.PSA;

namespace CUE4Parse_Conversion.Animations.XAnim
{
    /// <summary>
    /// Exports Call of Duty XAnim format (.XANIM_EXPORT)
    /// This is a text-based format used by Greyhound and other CoD modding tools
    /// Based on the Wraith XAnim format specification
    /// </summary>
    public class XAnimExporter
    {
        private readonly CAnimSet _animSet;
        private readonly int _sequenceIndex;
        private readonly ExporterOptions _options;
        private readonly string _animName;

        public XAnimExporter(CAnimSet animSet, int sequenceIndex, ExporterOptions options, string animName)
        {
            _animSet = animSet;
            _sequenceIndex = sequenceIndex;
            _options = options;
            _animName = animName;
        }

        public void Save(StreamWriter writer)
        {
            // XAnim format uses invariant culture for numbers
            var culture = CultureInfo.InvariantCulture;

            var sequence = _animSet.Sequences[_sequenceIndex];
            var numBones = _animSet.Skeleton.BoneCount;

            // Write header
            writer.WriteLine("// Generated by FModel - Unreal Engine asset extraction tool");
            writer.WriteLine($"// Export filename: '{_animName}.XANIM_EXPORT'");
            writer.WriteLine($"// Export time: {DateTime.Now}");
            writer.WriteLine();
            writer.WriteLine("ANIMATION");
            writer.WriteLine("VERSION 3");
            writer.WriteLine();

            // Count how many bones actually have animation data
            var animatedBones = 0;
            for (var boneIndex = 0; boneIndex < numBones; boneIndex++)
            {
                if (sequence.OriginalSequence.FindTrackForBoneIndex(boneIndex) >= 0)
                {
                    animatedBones++;
                }
            }

            // Write NUMPARTS first with bone names
            writer.WriteLine($"NUMPARTS {animatedBones}");
            var partIndex = 0;
            for (var boneIndex = 0; boneIndex < numBones; boneIndex++)
            {
                if (sequence.OriginalSequence.FindTrackForBoneIndex(boneIndex) < 0)
                    continue;

                var boneInfo = _animSet.Skeleton.ReferenceSkeleton.FinalRefBoneInfo[boneIndex];
                var boneName = boneInfo.Name.Text;
                writer.WriteLine($"PART {partIndex} \"{boneName}\"");
                partIndex++;
            }
            writer.WriteLine();

            // Write framerate and frame count
            writer.WriteLine($"FRAMERATE {sequence.FramesPerSecond.ToString(culture)}");
            writer.WriteLine($"NUMFRAMES {sequence.NumFrames}");

            // Write frame data
            for (var frame = 0; frame < sequence.NumFrames; frame++)
            {
                writer.WriteLine($"FRAME {frame + 1}"); // Frame indexing starts at 1
                
                // Calculate global transforms for this frame (accumulate parent transforms)
                var globalPositions = new FVector[numBones];
                var globalRotations = new FQuat[numBones];
                
                for (var i = 0; i < numBones; i++)
                {
                    var boneInfo = _animSet.Skeleton.ReferenceSkeleton.FinalRefBoneInfo[i];
                    var boneTransform = _animSet.Skeleton.ReferenceSkeleton.FinalRefBonePose[i];
                    
                    var position = boneTransform.Translation;
                    var rotation = boneTransform.Rotation;
                    var scale = FVector.OneVector;

                    // Only update transform if this bone has animation data
                    if (sequence.Tracks[i].HasKeys())
                    {
                        // Get the actual animated transform for this frame (local transform)
                        sequence.Tracks[i].GetBoneTransform(frame, sequence.NumFrames, ref rotation, ref position, ref scale);
                    }
                    
                    // Normalize quaternion to prevent drift and jitter
                    rotation = NormalizeQuat(rotation);
                    
                    // Calculate global transform by accumulating parent transforms
                    if (boneInfo.ParentIndex >= 0 && boneInfo.ParentIndex < i)
                    {
                        // Has a parent - accumulate transforms
                        var parentPos = globalPositions[boneInfo.ParentIndex];
                        var parentRot = globalRotations[boneInfo.ParentIndex];
                        
                        // Rotate local position by parent rotation, then add parent position
                        var rotatedPos = RotateVectorByQuat(position, parentRot);
                        globalPositions[i] = new FVector(
                            parentPos.X + rotatedPos.X,
                            parentPos.Y + rotatedPos.Y,
                            parentPos.Z + rotatedPos.Z
                        );
                        
                        // Combine rotations (parent * local)
                        var combinedRot = MultiplyQuats(parentRot, rotation);
                        // Normalize after multiplication to prevent accumulation errors
                        globalRotations[i] = NormalizeQuat(combinedRot);
                    }
                    else
                    {
                        // Root bone or no parent - use local transform as global
                        globalPositions[i] = position;
                        globalRotations[i] = rotation;
                    }
                }
                
                partIndex = 0;
                for (var boneIndex = 0; boneIndex < numBones; boneIndex++)
                {
                    if (sequence.OriginalSequence.FindTrackForBoneIndex(boneIndex) < 0)
                        continue;

                    var position = globalPositions[boneIndex];
                    var rotation = globalRotations[boneIndex];
                    
                    // Ensure quaternion is normalized before conversion
                    rotation = NormalizeQuat(rotation);

                    // Convert to CoD units (Unreal uses cm, CoD uses inches - 2.54 conversion)
                    var posX = position.X / 2.54f;
                    var posY = position.Y / 2.54f;
                    var posZ = position.Z / 2.54f;

                    // Convert quaternion to rotation matrix directly (no mirroring)
                    var q = new Quaternion(rotation.X, rotation.Y, rotation.Z, rotation.W);
                    var matrix = Matrix4x4.CreateFromQuaternion(q);

                    writer.WriteLine($"PART {partIndex}");
                    writer.WriteLine($"OFFSET {posX.ToString("F8", culture)} {posY.ToString("F8", culture)} {posZ.ToString("F8", culture)}");
                    writer.WriteLine($"SCALE 1.000000 1.000000 1.000000");
                    
                    // Write rotation matrix rows with higher precision
                    writer.WriteLine($"X {Clamp(matrix.M11).ToString("F8", culture)} {Clamp(matrix.M12).ToString("F8", culture)} {Clamp(matrix.M13).ToString("F8", culture)}");
                    writer.WriteLine($"Y {Clamp(matrix.M21).ToString("F8", culture)} {Clamp(matrix.M22).ToString("F8", culture)} {Clamp(matrix.M23).ToString("F8", culture)}");
                    writer.WriteLine($"Z {Clamp(matrix.M31).ToString("F8", culture)} {Clamp(matrix.M32).ToString("F8", culture)} {Clamp(matrix.M33).ToString("F8", culture)}");
                    writer.WriteLine();

                    partIndex++;
                }
            }

            // Write notetracks section
            writer.WriteLine("NOTETRACKS");
            writer.WriteLine();
            
            partIndex = 0;
            for (var boneIndex = 0; boneIndex < numBones; boneIndex++)
            {
                if (sequence.OriginalSequence.FindTrackForBoneIndex(boneIndex) < 0)
                    continue;

                writer.WriteLine($"PART {partIndex}");
                writer.WriteLine("NUMTRACKS 0");
                writer.WriteLine();
                partIndex++;
            }
        }

        private static float Clamp(float value, float min = -1.0f, float max = 1.0f)
        {
            return Math.Max(min, Math.Min(max, value));
        }

        private static FVector RotateVectorByQuat(FVector v, FQuat q)
        {
            // Convert quaternion to System.Numerics.Quaternion for rotation
            var quat = new Quaternion(q.X, q.Y, q.Z, q.W);
            var vec = new Vector3(v.X, v.Y, v.Z);
            var rotated = Vector3.Transform(vec, quat);
            return new FVector(rotated.X, rotated.Y, rotated.Z);
        }

        private static FQuat MultiplyQuats(FQuat a, FQuat b)
        {
            // Quaternion multiplication: result = a * b
            return new FQuat(
                a.W * b.X + a.X * b.W + a.Y * b.Z - a.Z * b.Y,
                a.W * b.Y - a.X * b.Z + a.Y * b.W + a.Z * b.X,
                a.W * b.Z + a.X * b.Y - a.Y * b.X + a.Z * b.W,
                a.W * b.W - a.X * b.X - a.Y * b.Y - a.Z * b.Z
            );
        }

        private static FQuat NormalizeQuat(FQuat q)
        {
            // Calculate magnitude
            var magnitude = MathF.Sqrt(q.X * q.X + q.Y * q.Y + q.Z * q.Z + q.W * q.W);
            
            // Avoid division by zero
            if (magnitude < 0.0001f)
            {
                // Return identity quaternion if too small
                return new FQuat(0, 0, 0, 1);
            }
            
            // Normalize
            return new FQuat(
                q.X / magnitude,
                q.Y / magnitude,
                q.Z / magnitude,
                q.W / magnitude
            );
        }
    }
}
