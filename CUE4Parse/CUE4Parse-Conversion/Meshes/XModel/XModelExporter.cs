using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using CUE4Parse.UE4.Objects.Core.Math;
using CUE4Parse.UE4.Objects.UObject;
using CUE4Parse_Conversion.Meshes.PSK;

namespace CUE4Parse_Conversion.Meshes.XModel
{
    /// <summary>
    /// Exports Call of Duty XModel format (.XMODEL_EXPORT)
    /// This is a text-based format used by Greyhound and other CoD modding tools
    /// Based on the Wraith XME format specification
    /// </summary>
    public class XModelExporter
    {
        private readonly CStaticMesh? _staticMesh;
        private readonly CSkelMeshLod? _skelMesh;
        private readonly CSkelMeshBone[]? _bones;
        private readonly string _modelName;

        public XModelExporter(CStaticMesh staticMesh, string modelName)
        {
            _staticMesh = staticMesh;
            _modelName = modelName;
        }

        public XModelExporter(CSkelMeshLod skelMesh, CSkelMeshBone[] bones, string modelName)
        {
            _skelMesh = skelMesh;
            _bones = bones;
            _modelName = modelName;
        }

        public void Save(StreamWriter writer)
        {
            // XModel format uses invariant culture for numbers
            var culture = CultureInfo.InvariantCulture;

            // Write header
            writer.WriteLine("// Generated by FModel - Unreal Engine asset extraction tool");
            writer.WriteLine("// Based on Wraith XME format for Call of Duty");
            writer.WriteLine("MODEL");
            writer.WriteLine("VERSION 6");
            writer.WriteLine();

            // Determine if we have bones
            var bones = _bones ?? Array.Empty<CSkelMeshBone>();
            var hasBones = bones.Length > 0;

            if (!hasBones)
            {
                // Create a default root bone for static meshes
                bones = new[] { new CSkelMeshBone { Name = new FName("tag_origin"), ParentIndex = -1, Position = FVector.ZeroVector, Orientation = FQuat.Identity } };
            }

            // Write bone count
            writer.WriteLine($"NUMBONES {bones.Length}");

            // Write bone hierarchy
            for (var i = 0; i < bones.Length; i++)
            {
                var bone = bones[i];
                writer.WriteLine($"BONE {i} {bone.ParentIndex} \"{bone.Name}\"");
            }

            writer.WriteLine();

            // Calculate global bone transforms
            var globalPositions = new FVector[bones.Length];
            var globalRotations = new FQuat[bones.Length];
            
            for (var i = 0; i < bones.Length; i++)
            {
                var bone = bones[i];
                
                if (bone.ParentIndex >= 0 && bone.ParentIndex < i)
                {
                    // Has a parent - accumulate transforms
                    var parentPos = globalPositions[bone.ParentIndex];
                    var parentRot = globalRotations[bone.ParentIndex];
                    
                    // Rotate local position by parent rotation, then add parent position
                    var rotatedPos = RotateVectorByQuat(bone.Position, parentRot);
                    globalPositions[i] = new FVector(
                        parentPos.X + rotatedPos.X,
                        parentPos.Y + rotatedPos.Y,
                        parentPos.Z + rotatedPos.Z
                    );
                    
                    // Combine rotations (parent * local)
                    globalRotations[i] = MultiplyQuats(parentRot, bone.Orientation);
                }
                else
                {
                    // Root bone or no parent - use local transform
                    globalPositions[i] = bone.Position;
                    globalRotations[i] = bone.Orientation;
                }
            }

            // Write bone transforms using global positions
            for (var i = 0; i < bones.Length; i++)
            {
                var globalPos = globalPositions[i];
                var globalRot = globalRotations[i];
                
                // Convert quaternion to rotation matrix
                var rotation = QuaternionToMatrix(globalRot);
                
                // Scale to CoD units (Unreal uses cm, CoD uses inches - 2.54 conversion)
                var posX = globalPos.X / 2.54f;
                var posY = globalPos.Y / 2.54f;
                var posZ = globalPos.Z / 2.54f;

                writer.WriteLine($"BONE {i}");
                writer.WriteLine($"OFFSET {posX.ToString(culture)}, {posY.ToString(culture)}, {posZ.ToString(culture)}");
                writer.WriteLine($"SCALE {1.0f.ToString(culture)}, {1.0f.ToString(culture)}, {1.0f.ToString(culture)}");
                writer.WriteLine($"X {Clamp(rotation.M11).ToString(culture)}, {Clamp(rotation.M12).ToString(culture)}, {Clamp(rotation.M13).ToString(culture)}");
                writer.WriteLine($"Y {Clamp(rotation.M21).ToString(culture)}, {Clamp(rotation.M22).ToString(culture)}, {Clamp(rotation.M23).ToString(culture)}");
                writer.WriteLine($"Z {Clamp(rotation.M31).ToString(culture)}, {Clamp(rotation.M32).ToString(culture)}, {Clamp(rotation.M33).ToString(culture)}");
            }

            writer.WriteLine();

            // Get vertices and indices
            var vertices = GetAllVertices();
            var totalVertCount = vertices.Sum(v => v.Length);
            var faces = GetAllFaces();
            var totalFaceCount = faces.Sum(f => f.Length);

            // Determine vertex format
            var useVert32 = totalVertCount > ushort.MaxValue;

            // Write vertex count
            if (useVert32)
            {
                writer.WriteLine($"NUMVERTS32 {totalVertCount}");
            }
            else
            {
                writer.WriteLine($"NUMVERTS {totalVertCount}");
            }

            // Track unique materials from all sections
            var materialSet = new HashSet<int>();
            for (var i = 0; i < faces.Length; i++)
            {
                var section = GetSection(i);
                if (section != null)
                {
                    materialSet.Add(section.MaterialIndex);
                }
            }

            // Write all vertices (they're all in vertices[0] for static meshes)
            var vertexIndex = 0;
            foreach (var meshVerts in vertices)
            {
                foreach (var vertex in meshVerts)
                {
                    // Scale position to CoD units
                    var posX = vertex.Position.X / 2.54f;
                    var posY = vertex.Position.Y / 2.54f;
                    var posZ = vertex.Position.Z / 2.54f;

                    if (useVert32)
                    {
                        writer.WriteLine($"VERT32 {vertexIndex}");
                    }
                    else
                    {
                        writer.WriteLine($"VERT {vertexIndex}");
                    }
                    
                    writer.WriteLine($"OFFSET {posX.ToString(culture)}, {posY.ToString(culture)}, {posZ.ToString(culture)}");

                    // Write bone weights
                    if (vertex is CSkelMeshVertex skelVert && skelVert.Influences.Count > 0)
                    {
                        writer.WriteLine($"BONES {skelVert.Influences.Count}");
                        foreach (var influence in skelVert.Influences)
                        {
                            writer.WriteLine($"BONE {influence.Bone} {influence.Weight.ToString(culture)}");
                        }
                    }
                    else
                    {
                        // Static mesh or no weights - bind to root bone
                        writer.WriteLine("BONES 1");
                        writer.WriteLine("BONE 0 1.000000");
                    }

                    writer.WriteLine();
                    vertexIndex++;
                }
            }

            // Write face count
            writer.WriteLine($"NUMFACES {totalFaceCount}");

            // Build material index mapping
            var materialList = materialSet.OrderBy(m => m).ToList();
            var materialIndexMap = new Dictionary<int, int>();
            for (var i = 0; i < materialList.Count; i++)
            {
                materialIndexMap[materialList[i]] = i;
            }

            // Write faces
            // For static meshes, vertices[0] contains all vertices and indices are absolute
            // For skeletal meshes, same thing - one vertex array
            var allVerts = vertices.Length > 0 ? vertices[0] : Array.Empty<CMeshVertex>();
            
            for (var meshIdx = 0; meshIdx < faces.Length; meshIdx++)
            {
                var meshFaces = faces[meshIdx];
                var section = GetSection(meshIdx);
                var materialIdx = section != null && materialIndexMap.ContainsKey(section.MaterialIndex) 
                    ? materialIndexMap[section.MaterialIndex] 
                    : 0;

                foreach (var face in meshFaces)
                {
                    writer.WriteLine($"TRI {meshIdx} {materialIdx} 0 0");

                    // XModel uses reverse winding order (Index3, Index1, Index2)
                    // Indices are absolute into the global vertex buffer
                    WriteFaceVertex(writer, allVerts[face.Index3], face.Index3, useVert32, culture);
                    WriteFaceVertex(writer, allVerts[face.Index1], face.Index1, useVert32, culture);
                    WriteFaceVertex(writer, allVerts[face.Index2], face.Index2, useVert32, culture);
                }
            }

            writer.WriteLine();

            // Write object count (submesh count)
            writer.WriteLine($"NUMOBJECTS {faces.Length}");
            for (var i = 0; i < faces.Length; i++)
            {
                writer.WriteLine($"OBJECT {i} \"{_modelName}_Mesh_{i}\"");
            }

            writer.WriteLine();

            // Write material count
            writer.WriteLine($"NUMMATERIALS {materialList.Count}");
            for (var i = 0; i < materialList.Count; i++)
            {
                var materialIndex = materialList[i];
                var materialName = GetMaterialName(materialIndex);
                var diffuseMap = GetDiffuseMapName(materialIndex);

                writer.Write($"MATERIAL {i} \"{materialName}\" \"Phong\" \"");
                
                if (!string.IsNullOrWhiteSpace(diffuseMap) && diffuseMap.Length < 112)
                {
                    writer.Write($"color:{diffuseMap}");
                }
                
                writer.WriteLine("\"");
                writer.WriteLine("COLOR 0.000000 0.000000 0.000000 1.000000");
                writer.WriteLine("TRANSPARENCY 0.000000 0.000000 0.000000 1.000000");
                writer.WriteLine("AMBIENTCOLOR 1.000000 1.000000 1.000000 1.000000");
                writer.WriteLine("INCANDESCENCE 0.000000 0.000000 0.000000 1.000000");
                writer.WriteLine("COEFFS 0.800000 0.000000");
                writer.WriteLine("GLOW 0.000000 0");
                writer.WriteLine("REFRACTIVE 6 1.000000");
                writer.WriteLine("SPECULARCOLOR 0.500000 0.500000 0.500000 1.000000");
                writer.WriteLine("REFLECTIVECOLOR 0.000000 0.000000 0.000000 1.000000");
                writer.WriteLine("REFLECTIVE 1 0.500000");
                writer.WriteLine("BLINN -1.000000 -1.000000");
                writer.WriteLine("PHONG 20.000000");
            }
        }

        private void WriteFaceVertex(StreamWriter writer, CMeshVertex vertex, int index, bool useVert32, CultureInfo culture)
        {
            if (useVert32)
            {
                writer.WriteLine($"VERT32 {index}");
            }
            else
            {
                writer.WriteLine($"VERT {index}");
            }

            // Unpack normal
            var normal = vertex.Normal;
            writer.WriteLine($"NORMAL {normal.X.ToString(culture)} {normal.Y.ToString(culture)} {normal.Z.ToString(culture)}");

            // Vertex color (default to white if not available)
            writer.WriteLine($"COLOR {1.0f.ToString(culture)} {1.0f.ToString(culture)} {1.0f.ToString(culture)} {1.0f.ToString(culture)}");

            // UV coordinates (do NOT flip V - XModel format uses UVs as-is from source)
            writer.WriteLine($"UV 1 {vertex.UV.U.ToString(culture)} {vertex.UV.V.ToString(culture)}");
        }

        private CMeshVertex[][] GetAllVertices()
        {
            if (_skelMesh != null && _skelMesh.Verts != null)
            {
                return new[] { _skelMesh.Verts };
            }

            if (_staticMesh != null)
            {
                var result = new List<CMeshVertex[]>();
                foreach (var lod in _staticMesh.LODs)
                {
                    if (lod is CStaticMeshLod staticLod && staticLod.Verts != null)
                    {
                        // For static meshes, all sections share the same vertex buffer
                        // Return the entire vertex array as a single mesh
                        result.Add(staticLod.Verts);
                        break; // Only process first LOD for now
                    }
                }
                return result.ToArray();
            }

            return Array.Empty<CMeshVertex[]>();
        }

        private CMeshFace[][] GetAllFaces()
        {
            var result = new List<CMeshFace[]>();

            if (_skelMesh != null && _skelMesh.Indices != null && _skelMesh.Sections != null)
            {
                var indices = _skelMesh.Indices.Value;
                foreach (var section in _skelMesh.Sections.Value)
                {
                    var faces = new List<CMeshFace>();
                    for (var i = 0; i < section.NumFaces; i++)
                    {
                        var faceIndex = (section.FirstIndex + i * 3);
                        if (faceIndex + 2 < indices.Length)
                        {
                            faces.Add(new CMeshFace
                            {
                                Index1 = (int)indices[faceIndex],
                                Index2 = (int)indices[faceIndex + 1],
                                Index3 = (int)indices[faceIndex + 2]
                            });
                        }
                    }
                    result.Add(faces.ToArray());
                }
            }
            else if (_staticMesh != null)
            {
                foreach (var lod in _staticMesh.LODs)
                {
                    if (lod is CStaticMeshLod staticLod && staticLod.Indices != null && staticLod.Sections != null)
                    {
                        var indices = staticLod.Indices.Value;
                        foreach (var section in staticLod.Sections.Value)
                        {
                            var faces = new List<CMeshFace>();
                            for (var i = 0; i < section.NumFaces; i++)
                            {
                                var faceIndex = (section.FirstIndex + i * 3);
                                if (faceIndex + 2 < indices.Length)
                                {
                                    // For static meshes, indices are absolute - use them as-is
                                    faces.Add(new CMeshFace
                                    {
                                        Index1 = (int)indices[faceIndex],
                                        Index2 = (int)indices[faceIndex + 1],
                                        Index3 = (int)indices[faceIndex + 2]
                                    });
                                }
                            }
                            result.Add(faces.ToArray());
                        }
                        break; // Only process first LOD for now
                    }
                }
            }

            return result.ToArray();
        }

        private CMeshSection? GetSection(int meshIdx)
        {
            if (_skelMesh?.Sections?.Value != null && meshIdx < _skelMesh.Sections.Value.Length)
            {
                return _skelMesh.Sections.Value[meshIdx];
            }

            if (_staticMesh != null)
            {
                var sectionCount = 0;
                foreach (var lod in _staticMesh.LODs)
                {
                    if (lod is CStaticMeshLod staticLod && staticLod.Sections?.Value != null)
                    {
                        foreach (var section in staticLod.Sections.Value)
                        {
                            if (sectionCount == meshIdx)
                            {
                                return section;
                            }
                            sectionCount++;
                        }
                    }
                }
            }

            return null;
        }

        private string GetMaterialName(int materialIndex)
        {
            var section = GetSectionByMaterialIndex(materialIndex);
            if (section?.Material?.Load() is { } material)
            {
                return material.Name.ToLowerInvariant();
            }
            return $"material_{materialIndex}";
        }

        private string GetDiffuseMapName(int materialIndex)
        {
            var section = GetSectionByMaterialIndex(materialIndex);
            if (section?.Material?.Load() is { } material)
            {
                // Try to find diffuse/color map name
                return material.Name + "_Diffuse";
            }
            return string.Empty;
        }

        private CMeshSection? GetSectionByMaterialIndex(int materialIndex)
        {
            if (_skelMesh?.Sections?.Value != null)
            {
                foreach (var section in _skelMesh.Sections.Value)
                {
                    if (section.MaterialIndex == materialIndex)
                    {
                        return section;
                    }
                }
            }

            if (_staticMesh != null)
            {
                foreach (var lod in _staticMesh.LODs)
                {
                    if (lod is CStaticMeshLod staticLod && staticLod.Sections?.Value != null)
                    {
                        foreach (var section in staticLod.Sections.Value)
                        {
                            if (section.MaterialIndex == materialIndex)
                            {
                                return section;
                            }
                        }
                    }
                }
            }

            return null;
        }

        private static Matrix4x4 QuaternionToMatrix(FQuat quat)
        {
            var q = new Quaternion(quat.X, quat.Y, quat.Z, quat.W);
            return Matrix4x4.CreateFromQuaternion(q);
        }

        private static FVector RotateVectorByQuat(FVector vec, FQuat quat)
        {
            // Convert to System.Numerics types
            var q = new Quaternion(quat.X, quat.Y, quat.Z, quat.W);
            var v = new Vector3(vec.X, vec.Y, vec.Z);
            
            // Rotate vector by quaternion
            var rotated = Vector3.Transform(v, q);
            
            return new FVector(rotated.X, rotated.Y, rotated.Z);
        }

        private static FQuat MultiplyQuats(FQuat a, FQuat b)
        {
            // Convert to System.Numerics types
            var qa = new Quaternion(a.X, a.Y, a.Z, a.W);
            var qb = new Quaternion(b.X, b.Y, b.Z, b.W);
            
            // Multiply quaternions (order matters: parent * local)
            var result = Quaternion.Multiply(qa, qb);
            
            return new FQuat(result.X, result.Y, result.Z, result.W);
        }

        private static float Clamp(float value, float min = -1.0f, float max = 1.0f)
        {
            return Math.Max(min, Math.Min(max, value));
        }

        private class CMeshFace
        {
            public int Index1;
            public int Index2;
            public int Index3;
        }
    }
}
